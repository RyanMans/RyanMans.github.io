<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[webpack全篇详解]]></title>
    <url>%2F2019%2F04%2F21%2Fwebpack%E5%85%A8%E7%AF%87%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[webpack4.0 全篇详解一、初识webpack官网图解: 1.1 什么是webpackwebpack 是一个现代 JavaScript 应用程序的静态模块打包工具：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并生成一个或多个 bundle，将其打包为合适的格式以供浏览器使用 webpack构建： 1构建就是把源代码转化成线上浏览器可执行的JavaScript、CSS、HTML等代码 主要有如下7个操作： 123456789101112131.代码转换：TypeScript 编译成 JavaScript、SCSS或Less 编译成 CSS 等。2.文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。3.代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。4.模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。5.自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器,nodemon。6.代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。7.自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。 如图示: 构建其实是工程化、自动化思想在前端开发中的体现，把一系列流程用代码去实现，让代码自动化地执行这一系列的流程。构建给前端开发注入了更大的活力，解放了我们的生产力,更加方便了我们的开发。 1.2 什么是webpack模块二、webpack项目的基本搭建2.1 搭建webpack环境 Node.js安装 Node官网 Mac OSX系统安装Node的流程: 安装Homebrew： 12345Homebrew简称brew，是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件打开终端,执行以下命令安装Homebrew:ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; Node安装： 123打开终端,执行以下命令安装node: brew install node查看版本,检查是否安装成功: node -v npm -v Cnpm安装： 由于npm走的是国外网络，比较慢容易出现安装失败的现象,所以可以切换成国内的镜像资源: 1234567cnpm和npm用法一致, 只是使用过的是国内的淘宝镜像,效率会比npm高很多打开终端,执行以下命令安装cnpm:npm install cnpm -g --registry=https://registry.npm.taobao.org查看版本,检查是否安装成功: cnpm -v 2.2 webpack项目初始化配置在桌面上新建一个webpack-simple-project. 并使用终端(terminal),在其路径下新建package.json文件: 123451. mkdir webpack-simple-project2. npm init 或者 cnpm init. // 全部回车点击3. npm init -y 或者 cnpm init -y. //-y 会 默认所有的配置 package.json基本结构:123456789101112&#123; &quot;name&quot;: &quot;webpack-simple-project&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 在这个文件中, 我们可以在 “scripts” 脚本命令中,来配置我们常用的脚本命令,例如: 12345678910111213&#123; ... ... &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;webpack --mode production&quot;,//npm run build 启动我们的webpack,生产环境 &quot;dev&quot;: &quot;webpack --mode development&quot;,//npm run dev 启动我们的webpack,生产环境 &#125;, ... ...&#125; 2.3 安装webpack 全局安装 一般不建议全局安装，防止两个不同项目引用了webpack的不同版本，就会出现版本不统一运行不起来的情况，需要卸载掉当前版本安装对应版本，就会比较麻烦。12345npm install webpack webpack-cli -g或者cnpm install webpack webpack-cli -g 局部项目安装 12345npm install webpack webpack-cli --save-dev或者cnpm install webpack webpack-cli --save-dev 本项目采用局部安装，在4.0之后，webpack和webpack-cli已分开，需要单独安装 123456789101. cd webpack-simple-project 路径下2. npm install webpack webpack-cli --save-dev3. npx webpack -v //查看版本号4. npm info webpack //查看对用包的详细信息 //可以安装指定版本包（例子） npm install webpack@4.16.1 webpack-cli -D 注意: 1由于NPM访问的是国外镜像资源，如果出现安装失败的情况，建议更换成国内的镜像资源cnpm下载安装。 2.4 webpack的配置文件webpack 开箱即用，可以无需使用任何配置文件。然而，webpack 会假定项目的入口起点为 src/index ，然后会在 dist/main.js 输出结果，并且在生产环境开启压缩和优化。通常，你的项目还需要继续扩展此能力，为此你可以在项目根目录下创建一个 webpack.config.js 文件，webpack 会自动使用它。 在项目根目录下新建 webpack.config.js 文件，这是webpack默认配置文件，详情请看 官网配置 1234567891011121314151617181920212223const path = require(&apos;path&apos;); //引入我们的node模块的pathmodule.export = &#123; //默认是production，打包的文件默认被压缩。开发时可以设置为development，不被压缩 mode:&apos;production&apos;, //打包项目的入口文件 entry:&apos;./src/app.js&apos;, //打包项目的输出文件 output:&#123; //自定义打包输出文件名 filename:&apos;js/[name].js&apos;, //文件名默认[name].js, 可以在前面加上相对路径,生成包裹js文件的文件夹 //输出文件的绝对路径 path:path.resolve(__dirname,&apos;dist&apos;), //定位,输出文件的目标路径 //输出文件的公共路径 publicPath:&apos;http://cdn.com/&apos;,//公共路径,可以理解为绝对地址(域名) &#125;, ... ... &#125; 2.5 项目文件引入并开始打包在webpac-simple-project项目中,我们的文件结构树如下: 开始对js文件的引入: 在index.html中，引入打包好的文件路径 dist/index.js 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;webpack simple project&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 该路径为项目打包好的文件路径,可以使用html-webpack-plugin写入这个script的引入--&gt; &lt;script src=&quot;dist/index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 开始对项目开始打包构建，打开terminal 定位到项目的根目录路径下，执行npm命令 1231. cd webpack simple project目录下2. npm run build 输出内容如下: 三、webpack的核心概念 - Loader篇3.1 什么是loader1webpack可以使用loader 来预处理那些非 JavaScript 文件，就是通过使用不同的Loader，webpack可以把不同的静态文件都编译成js文件，比如css,sass,less,ES6/7,vue,JSX等 loader概念图解: 官网loader loader 支持串联的方式多个loader使用,在node的环境下也可以运行,支持同步和异步. 多loader使用时,要注意先后顺序,从右往左开始编译执行的. 3.2 使用Loader打包处理JS文件 babel-loader的使用 作用: babel-loader的作用正是实现对使用了ES2015+语法的.js文件进行处理. 命令: 1npm/cnpm install babel-loader --save-dev babel-core的安装:它的作用在于提供一系列api。这便是说，当webpack使用babel-loader处理文件时，babel-loader实际上调用了babel-core的api 1npm/cnpm install babel-core --save-dev babel-preset-env的安装:它的作用在于告诉babel使用哪种转码规则进行文件处理 1npm/cnpm install babel-preset-env --save-dev babel的配置方式 第一种方式是通过package.json。在package.json文件中增加一个“babel”属性，该属性是一个JSON对象，作用是设置项目中的babel转码规则和使用到的babel插件: 123456789&#123; ... &quot;babel&quot;:&#123; &quot;presets&quot;: [], &quot;plugins&quot;: [] &#125; ...&#125; 通过.babelrc文件, 在根目录下新建.babelrc文件, 里面默认输入“babel”的属性的值即可: 123456xxx.babelrc:&#123; &quot;presets&quot;: [&quot;env&quot;], &quot;plugins&quot;: []&#125; 在 webpack.config.js 里 添加loader配置123456789101112131415161718const path = require(&apos;path&apos;);//物理路径//__dirname,当前运行环境下的变量,也就是当前环境下的绝对路径,后面会跟着一个相对路径&#123; ... module:&#123; rules:[ &#123; test:/\.js$/, include:path.resolve(__dirname, &apos;src&apos;), exclude: path.resolve(__dirname,&quot;node_modules&quot;), // /node_modules/, //指定排除处理的范围文件,提高打包的速度,可以是正则表达式,还有绝对路径 loader: &quot;babel-loader&quot; &#125; ] &#125; ...&#125; 项目文件的引入并打包 在src目录下，存在app.js 和 a.js 文件, 代码引入如下: a.js文件代码:1234567function arrowToast ()&#123; alert([1,2,3].map(n =&gt; n + 1)); //等同于alert([1,2,3].map(function(n)&#123;return n+1&#125;))&#125;module.exports = &#123; arrowToast:arrowToast&#125; app.js文件代码:123456789var a = require(&apos;./a.js&apos;) function helloWorld (str)&#123; alert(str) &#125; helloWorld(&quot;helloWorld&quot;); a.arrowToast(); 开始对项目开始打包构建，打开terminal 定位到项目的根目录路径下，执行npm命令 1terminal 定位到根目录下 运行 npm run build 打开我们的dist文件下的index.html, 在浏览器运行, 可以看到我们的页面效果会执行两个弹窗事件 1第一次是“helloWorld”, 第二次是a.js中的es6方法函数结果 &quot;&quot;2,3,4&quot;&quot; 常见错误: 1234567如果出现下面的打包错误:Error: Cannot find module &apos;@babel/core&apos;那是因为babel-loader的版本过高, 找不到babel-core. 两者之间不匹配, 这个时候的办法, 是先重新安装babel-loader,回退版本到7.0多“cnpm install babel-loader@7.1.5 --save-dev” 这样对于babel-loader的配置,也基本成功完成了. 3.3 使用Loader打包处理静态文件3.3.1 支持加载样式CSS文件 style-loader的使用 作用: 能够在需要载入的html中创建一个标签,style-loader加载到的css样式动态的添加该标签中. 命令: 1npm/cnpm install style-loader --save-dev css-loader的使用 作用: 允许在js中import一个css文件，会将css文件当成一个模块引入到js文件中. 只会加载引入到js文件中的css文件. 命令: 1npm/cnpm install css-loader --save-dev 项目文件的引入并打包 在src目录下，会有一个style文件和app.js,style下包含一个app.css文件 ,代码如下： app.js文件代码: 1import &quot;./style/app.css&quot;; //对css文件进行引入 在 webpack.config.js 里 添加loader配置 12345678910module.exports = &#123; module: &#123; rules: [ &#123; test: /\.css$/, //匹配以css为后缀的文件 use: [&apos;style-loader&apos;, &apos;css-loader&apos;],//loader的执行顺序是从右向左，从下到上。css-loader：分析几个css文件之间的关系，最终合并为一个css。style-loader:在得到css生成的内容时，把其挂载到html的head里，成为内联样式。 &#125;, ], &#125;,&#125;; 3.3.2 支持加载样式SASS文件 sass-loader的使用 作用: 对项目中的scss文件进行处理 命令: 123 npm/cnpm install scss-loader --save-dev (node-sass可不安装)``` 在 &lt;span style=&quot;background-color: #fff5f5;color: #ff502c;&quot;&gt; webpack.config.js&lt;/span&gt; 里 添加loader配置 module.exports = { … module: { rules: [{ test: /.scss$/, use: [ “style-loader”, // 将 JS 字符串生成为 style 节点 “css-loader”, // 将 CSS 转化成 CommonJS 模块 “sass-loader” // 将 Sass 编译成 CSS，默认使用 Node Sass ] }] }};1234567##### 3.3.3 支持加载样式less文件- **less-loader的使用**作用: 对项目中的less文件进行处理命令: cnpm install less –save-dev npm/cnpm install less-loader –save-dev1在 &lt;span style=&quot;background-color: #fff5f5;color: #ff502c;&quot;&gt; webpack.config.js&lt;/span&gt; 里 添加loader配置 module.exports = { … module: { rules: [{ test: /.scss$/, use: [ “style-loader”, // 将 JS 字符串生成为 style 节点 “css-loader”, // 将 CSS 转化成 CommonJS 模块 “sass-loader”, // 将 Sass 编译成 CSS，默认使用 Node Sass “less-loader” ] }] }};123456##### 3.3.4 为 css 样式属性加不同浏览器的前缀件为了浏览器的兼容性，在不同的浏览器中，使用个别样式时必须加入`-webkit,-ms,-o,-moz`这些前缀&lt;span style=&quot;font-size:13px;font-weight:bold;color:#888;&quot;&gt; 浏览器内核:&lt;/span&gt; Trident内核：主要代表为IE浏览器, 前缀为-ms Gecko内核：主要代表为Firefox, 前缀为-moz Presto内核：主要代表为Opera, 前缀为-o Webkit内核：产要代表为Chrome和Safari, 前缀为-webkit 12345- **postcss-loader的使用**作用: 其主要是对css文件的预处理,autoprefixer是它的一个插件,主要是对css文件添加兼容性前缀命令: npm/cnpm install postcss-loader –save-dev cnpm install autoprefixer –save-dev. //属于postcss的插件 1234**项目中对autoprefixer的配置**1. 第一种方式是通过 postcss.config.js。在项目根目录下创建 postcss.config.js文件，代码如下: module.exports = { plugins: [ require(‘autoprefixer’) ]}1在 &lt;span style=&quot;background-color: #fff5f5;color: #ff502c;&quot;&gt; webpack.config.js&lt;/span&gt; 里 添加loader配置 module.exports = { … module: { rules: [{ test: /.scss$/, use: [ “style-loader”, // 将 JS 字符串生成为 style 节点 “css-loader”, // 将 CSS 转化成 CommonJS 模块 “sass-loader”, // 将 Sass 编译成 CSS，默认使用 Node Sass “less-loader” “postcss-loader” ] }] }};123452. 第二种方式是直接在webpack.config.js文件配置对loader的特别支持在 &lt;span style=&quot;background-color: #fff5f5;color: #ff502c;&quot;&gt; webpack.config.js&lt;/span&gt; 里 添加loader配置 module.exports = { … module: { test:/.(sc|le|c)ss$/, // 项目中如果有多个ss文件结尾时,正则表达式可以这么使用,最新执行的再前面 use:[{ loader:’style-loader’ },{ loader:’css-loader’, options:{ importLoaders:1， ////如果sass文件里还引入了另外一个sass文件，另一个文件还会从postcss-loader向上解析。如果不加，就直接从css-loader开始解析。 modules: true //开启css的模块打包。css样式不会和其他模块发生耦合和冲突 } },{ loader:&quot;less-loader&quot; },{ loader:&quot;sass-loader&quot; },{ loader:&apos;postcss-loader&apos;, //autoprefixer使用该插件为各浏览器支持的属性加上前缀 options:{ plugins:[require(&quot;autoprefixer&quot;)(&quot;last 5 versions&quot;)] } }, ], include:path.resolve(__dirname, &apos;src&apos;), }, };12345678910##### 3.3.5 支持加载图片文件- **file-loader的使用**作用: 对项目中引入的资源文件(图片)进行处理，解决CSS等文件中的引入图片路径问题。 详细请看官方文档：[官网: file-loader](https://webpack.js.org/loaders/file-loader/)命令: npm/cnpm install file-loader –save-dev12在 &lt;span style=&quot;background-color: #fff5f5;color: #ff502c;&quot;&gt; webpack.config.js&lt;/span&gt; 里 添加loader配置 module.exports = { //配置模块,主要用来配置不同文件的加载器 module: { //配置模块规则 rules: [ { test: /.(png|svg|jpg|jpeg|gif)$/, //正则匹配要使用相应loader的文件 use: [ { loader: ‘file-loader’, //要用到的loader options: { //palceholder占位符 name:’[name].[ext]’, //打包后的图片名字，后缀和打包的之前的图片一样 outputPath: ‘images/‘ //图片打包后的地址 }, }, ], }, ], },}; 1234567- **url-loader的使用**作用: &lt;span style=&quot;font-weight:bold;&quot;&gt;将小图片转换成base64格式。&lt;/span&gt; 已经具备了file-loader的功能,使用时,可以不引用file-loader. 但是url-loader可以将图片转成base64字符,能更快的加载图片,一旦图片过大,就会使用file-loader的加载本地图片。详细请看官方文档：[官网: url-loader](https://webpack.js.org/loaders/url-loader/) 命令: npm/cnpm install url-loader –save-dev123在 &lt;span style=&quot;background-color: #fff5f5;color: #ff502c;&quot;&gt; webpack.config.js&lt;/span&gt; 里 添加loader配置 module.exports = { module: { rules: [ { test: /.(png|jpg|gif|bmp/)$/i, use: [ { loader: ‘url-loader’, options: { name:’[name].[ext]’, outputPath: ‘images/‘, limit: 8192 //小于8192b,就可以转化成base64格式。大于就会打包成文件格式 } } ] } ] }} 12###### file-loader和url-loader使用注意: 在css文件中对图片资源文件的引入可以使用相对路径: app.css文件中: .imgClass{ width:400px; height: 400px; background: url(‘../assets/test.jpg’);} .imgSize{ width:400px; height: 400px; } 在html中如果使用img标签的src 对图片进行使用,需要“使用绝对路径”. 如果要使用相对路径,则需要如下: 123456- **image-webpack-loader**作用:对引入项目中的图片文件进行压缩处理命令: npm/cnpm install image-webpack-loader –save-dev 12在 &lt;span style=&quot;background-color: #fff5f5;color: #ff502c;&quot;&gt; webpack.config.js&lt;/span&gt; 里 添加loader配置 module.exports = { module: { rules: [ { test: /.(png|jpg|gif|bmp/)$/i, use: [ { loader: ‘url-loader’, options: { name:’[name].[ext]’, outputPath: ‘images/‘, limit: 8192 //小于8192b,就可以转化成base64格式。大于就会打包成文件格式 } }, { loader:’image-webpack-loader’, //对图片资源进行压缩处理 } ] } ] }} 12345678##### 3.4 使用Loader打包处理HTML文件- **html-loader**作用: 对项目中引入的模版html文件进行处理(必须在js文件中引入)命令: npm/cnpm install html-loader –save-dev1234567891011**项目文件的引入并打包**在webpac-simple-project项目中,我们的文件结构树如下:![](https://note.youdao.com/yws/public/resource/e6428a61e19f9257b89663f8ddeffc1b/xmlnote/22B49E40057D42A9ADD9D2153E6A42D0/3407)在src目录下，存在`components文件夹 和 app.js` 文件, 代码引入如下:&lt;span style=&quot;font-size:12px;font-weight:bold;color:#888;&quot;&gt; components文件夹下的layer.js文件代码:&lt;/span&gt; //ES6语法import template from ‘./layer.html’import “./layer.css”;// import “./layer.less”; function layer (){ return{ name:”layer”, tpl:template }} //导出export default layer;12&lt;span style=&quot;font-size:12px;font-weight:bold;color:#888;&quot;&gt; components文件夹下的layer.html文件代码:&lt;/span&gt; this is a layer12&lt;span style=&quot;font-size:12px;font-weight:bold;color:#888;&quot;&gt; app.js对layer模板的引入:&lt;/span&gt; // ES6语法import Layer from ‘./components/layer/layer.js’ const App = function (){ var dom = document.getElementById(‘app’); dom.innerHTML = new Layer().tpl; console.log(dom); console.log(Layer); } new App(); 12根目录下运行: npm run build 打包之后, 我们可以在dist/index.html 浏览器运行之后,可以成功看到layer模版已经写入id为app的标签下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778##### 3.5 完整的webpack.config.js 对loader的支持``` const path = require(&apos;path&apos;);//const htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);module.exports = &#123; entry:&quot;./src/app.js&quot;, output:&#123; filename:&quot;js/[name].js&quot;, path:path.resolve(__dirname,&apos;dist&apos;) //__dirname,当前运行环境下的变量,也就是当前环境下的绝对路径,后面会跟着一个相对路径 &#125;, plugins:[ new htmlWebpackPlugin(&#123; template:&apos;index.html&apos;, filename:&apos;index.html&apos;, inject:true &#125;)], module:&#123; //loader使用方法 rules:[ &#123; test:/\.js$/, include:path.resolve(__dirname, &apos;src&apos;), exclude: path.resolve(__dirname,&quot;node_modules&quot;), // /node_modules/, //指定排除处理的范围文件,提高打包的速度,可以是正则表达式,还有绝对路径 loader: &quot;babel-loader&quot; &#125;,&#123; test:/\.html$/, //使用html-loader对html模版内容进行引入. // include:path.resolve(__dirname, &apos;src&apos;), loader: &quot;html-loader&quot; &#125;,&#123; test:/\.(png|svg|jpg|jpeg|gif)$/i, //使用file-loader对资源文件的引入,i不区分大小写 include:path.resolve(__dirname, &apos;src&apos;), use: [ // &#123; // loader:&apos;file-loader&apos;, // options:&#123; // name:&apos;assets/[name]-[hash:5].[ext]&apos;, //设置资源图片打包后的地址 // &#125; // &#125;, &#123; loader:&apos;url-loader&apos;, options:&#123; limit:20000, //限制图片的最大字节 name:&apos;assets/[name]-[hash:5].[ext]&apos;, //设置资源图片打包后的地址 &#125; &#125;, &#123; loader:&apos;image-webpack-loader&apos;, //对图片资源进行压缩处理 &#125; ] &#125;,&#123; test:/\.(sc|le|c)ss$/, // 项目中如果有多个ss文件结尾时,正则表达式可以这么使用,最新执行的再前面 // loader:&apos;style-loader!css-loader!less-loader&apos; 没有postcss-loader可以直接这样使用 use:[&#123; loader:&apos;style-loader&apos; &#125;,&#123; loader:&apos;css-loader&apos;, options:&#123; importLoaders:1 &#125; &#125;,&#123; loader:&quot;less-loader&quot; &#125;,&#123; loader:&quot;sass-loader&quot; &#125;,&#123; loader:&apos;postcss-loader&apos;, //autoprefixer使用该插件为各浏览器支持的属性加上前缀 options:&#123;plugins:[require(&quot;autoprefixer&quot;)(&quot;last 5 versions&quot;)]&#125; &#125;, ], include:path.resolve(__dirname, &apos;src&apos;), &#125;, ] &#125;&#125; 项目结构图 Github地址:webpack-loader四、webpack的核心概念 - Plugin篇4.1 什么是plugin12 plugin是webpack的支柱, 主要是为了解决loader无法实现的其他事情.想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义,你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例 常见plugin概念图解: 官网plugin 4.2 常用的plugin插件 html-webpack-plugin 作用: 打包项目中的html文件, 并生成对应打包的html文件. 命令: 1npm/cnpm install html-webpack-plugin --save-dev 介绍:1234567891011121314151.file: 指定生成的文件2.filename: 指定生成的文件名称, 优先级比file高, 两者取一即可3.template: 需要被打包的html文件路径4.inject: 主要是指定引入的js文件写入到html文件的位置. 主要有true(默认值,body底部)、body(body底部)、head(html标签的head)、false(不写入生成的js文件,基本不会用)5.minify对象:主要是对html文件进行压缩,可去npm官网(https://www.npmjs.com/package/html-webpack-plugin)查看对应的属性配置 6.chunks:指定哪些需要被引入打包的模块7.excludeChunks:指定哪些不需要被引入打包的模块,而其他的chunks将会被引入. 且与优先级高于chunks, 也就是说当两者同时存在时,excludeChunks如果包含chunks中的chunk,则该chunk也不会被引入 在 webpack.config.js 里 添加plugin配置 12345678910111213141516171819202122232425const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); //打包html文件module.exports = &#123; entry: &apos;./src/index.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), //定位,输出文件的目标路径 filename: &apos;js/[name].js&apos;,//文件名默认[name].js, &#125;, // webpack 中对于plugin的学习 plugins: [ //数组, 支持生成多页面的html文件 new HtmlWebpackPlugin(&#123; //将模板的头部和尾部添加css和js模板,dist 目录发布到服务器上，项目包。可以直接上线 file: &apos;app.html&apos;, //指定要生成的文件 filename: &apos;app.html&apos;, //指定要生成的文件名称,优先级比file高, 两者指定一个就可以,加上hash会每次生成不同的html文件 template: &apos;index.html&apos;, //需要被打包的模版html inject: &apos;body&apos;, //指定脚本插入的标签位置, 可以是head,body等标签 title: &apos;webpack is good&apos;, minify: &#123; //对html文件进行压缩 removeComments: true, //删除打包的文件内部代码注释 collapseWhitespace: true, //删除空格 &#125;, &#125;), ], ...&#125; clean-webpack-plugin 作用: 自动清除上一次打包的dist文件 命令: 1npm/cnpm install clean-webpack-plugin --save-dev 1234567891011121314151617const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);const path = require(&apos;path&apos;);module.exports = &#123; entry: &apos;./src/index.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;./dist&apos;), filename: &apos;js/[name].js&apos;,//文件名默认[name].js, &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: &apos;index.html&apos; //在打包之后，以.html为模板，把打包生成的js自动引入到这个html文件中 &#125;), new CleanWebpackPlugin([&apos;dist&apos;]), // 在打包之前，可以删除dist文件夹下的所有内容 ]&#125;; source-map 作用: 打包编译后的文件和源文件的映射关系，用于开发者调试用。 命令: 1npm/cnpm install clean-webpack-plugin --save-dev 123456789source-map 把映射文件生成到单独的文件，最完整但最慢cheap-module-source-map 在一个单独的文件中产生一个不带列映射的Mapeval-source-map 使用eval打包源文件模块,在同一个文件中生成完整sourcemapcheap-module-eval-source-map sourcemap和打包后的JS同行显示，没有映射列development环境推荐使用： devtool: &apos;cheap-module-eval-source-map&apos;,production环境推荐使用： devtool: &apos;cheap-module-source-map&apos;, webpack-dev-server 作用: 解决每次在src里编写完代码都需要手动重新运行 npm run dev 命令: 1npm install webpack-dev-server --save-dev 介绍: 1234567891. contentBase :配置开发服务运行时的文件根目录2. open :自动打开浏览器3. host：开发服务器监听的主机地址4. compress :开发服务器是否启动gzip等压缩5. port：开发服务器监听的端口 解决每次在src里编写完代码都需要手动重新运行 npm run dev，在 package.json 里添加配置 123456789101112&#123; &quot;name&quot;: &quot;haiyang&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;bundle&quot;: &quot;webpack&quot;, &quot;watch&quot;: &quot;webpack --watch&quot;,// 加--watch自动监听代码的变化 &#125;, &#125; 在 webpack.config.js 里 添加plugin配置 123456789101112131415161718192021222324252627const path = require(&apos;path&apos;);const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);module.exports = &#123; mode: &apos;development&apos;, devtool: &apos;cheap-module-eval-source-map&apos;, entry: &#123; main: &apos;./src/index.js&apos; &#125;,+ devServer: &#123; contentBase: &apos;./dist&apos;, open: true, port: 8080, proxy: &#123;//配置跨域，访问的域名会被代理到本地的3000端口 &apos;/api&apos;: &apos;http://localhost:3000&apos; &#125; &#125;, module: &#123; rules: [] &#125;, plugins: [], output: &#123; filename: &apos;[name].js&apos;, path: path.resolve(__dirname, &apos;dist&apos;) &#125;&#125; 在 package.json 中 添加热更新 12345678910111213&#123; &quot;name&quot;: &quot;haiyang&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;bundle&quot;: &quot;webpack&quot;, &quot;watch&quot;: &quot;webpack --watch&quot;,// 加--watch自动监听代码的变化 &quot;start&quot;: &quot;webpack-dev-server&quot;,//配置热更新 &#125;, &#125; 4.3 plugin对多页面项目的配置支持在 webpack.config.js 里 添加plugin配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); //打包html文件module.exports = &#123; //context:&apos;&apos; //整个环境的上下文, 也就是项目根目录 entry: &#123; //入口文件, 在vue-cli中是main.js main: &apos;./src/index.js&apos;, app: &apos;./src/app.js&apos;, home: &apos;./src/home.js&apos;, mine: &apos;./src/mine.js&apos;, &#125;, output: &#123; //webpack如何向外输出 path: path.resolve(__dirname, &apos;dist&apos;), //定位,输出文件的目标路径 filename: &apos;js/[name].js&apos;,//文件名默认[name].js, 可以在前面加上相对路径,生成包裹js文件的文件夹 //也可用hash chunkhash结合配置. [name]-[hash].js [name]-[chunkhash].js. //使用chunkhash,在打包的时候,如果文件无修改,则不会在打包. 等同于版本号,使用用于多页面 publicPath: &apos;http://cdn.com/&apos; //公共路径, 可以理解为绝对地址(域名), 设置publicpath,在打包输出的时候, //在html中引入的路径会以publicPath+path+filename.js这两个路径拼接后的文件名称引入 &#125;, // webpack 中对于plugin的学习 plugins: [ //数组, 支持生成多页面的html文件 new HtmlWebpackPlugin(&#123; //将模板的头部和尾部添加css和js模板,dist 目录发布到服务器上，项目包。可以直接上线 file: &apos;app.html&apos;, //指定要生成的文件 filename: &apos;app.html&apos;, //指定要生成的文件名称,优先级比file高, 两者指定一个就可以,加上hash会每次生成不同的html文件 template: &apos;index.html&apos;, //需要被打包的模版html inject: &apos;body&apos;, //指定脚本插入的标签位置, 可以是head,body等标签 title: &apos;webpack is good&apos;, minify: &#123; //对html文件进行压缩 removeComments: true, //删除打包的文件内部代码注释 collapseWhitespace: true, //删除空格 &#125;, chunks: [&apos;main&apos;, &apos;app&apos;] &#125;), new HtmlWebpackPlugin(&#123; //home页面 filename: &apos;home.html&apos;, template: &apos;home.html&apos;, inject: true, chunks: [&apos;main&apos;, &apos;home&apos;] //chunks属性,指定每一个模版要引入的chunk(js文件),而且是作为数组存在,其内部对象为要引入的chunk名称. &#125;), new HtmlWebpackPlugin(&#123; //mine页面 filename: &apos;mine.html&apos;, template: &apos;mine.html&apos;, inject: true, //chunks:[&apos;main&apos;,&apos;home&apos;], excludeChunks和chunks最好两者取其一,互不包含 excludeChunks: [&apos;home&apos;, &apos;app&apos;], //指定哪些不被引入的chunk(js文件),而剩下的其他chunk,将在该模版进行引入, 它和chunks属性对立, //且与优先级高于chunks,也就是说当两者同时存在时,excludeChunks如果包含chunks中的chunk,则该chunk也不会被引入 &#125;) ], ...&#125; Github地址:webpack-simple-project]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中使用Animate.css库]]></title>
    <url>%2F2019%2F04%2F21%2FVue%E4%B8%AD%E4%BD%BF%E7%94%A8Animate-css%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Vue中使用Animate.css库利用transition定义css3中@keyframs 中的动效 bounce-in123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Vue中使用Animate.css库&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./vue-dev.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; @keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125; &#125; .fade-enter-active &#123; animation: bounce-in 1s; transform-origin: left center; &#125; .fade-leave-active &#123; animation: bounce-in 1s; transform-origin: left center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;div v-show=&quot;show&quot;&gt;hello world&lt;/div&gt; &lt;/transition&gt; &lt;button @click=&quot;handleClickEvent&quot;&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &apos;#app&apos;, data() &#123; return &#123; show: true &#125; &#125;, methods: &#123; handleClickEvent: function() &#123; this.show = !this.show; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; transition自定义类名语法： 1enter-active-class=&quot;xxx&quot; 或 leave-active-class=&quot;xxx&quot; 页面代码如下:1234567891011121314151617181920212223242526272829303132333435&lt;style type=&quot;text/css&quot;&gt;@keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125;&#125;.active &#123; animation: bounce-in 1s; transform-origin: left center;&#125;.leave &#123; animation: bounce-in 1s; transform-origin: left center;&#125;&lt;/style&gt;&lt;div id=&quot;app&quot;&gt; &lt;transition name=&quot;fade&quot; enter-active-class=&quot;active&quot; //自定义添加class名 leave-active-class=&quot;leave&quot; &gt; &lt;div v-show=&quot;show&quot;&gt;hello world&lt;/div&gt; &lt;/transition&gt; &lt;button @click=&quot;handleClickEvent&quot;&gt;切换&lt;/button&gt;&lt;/div&gt; 使用Animate.css库复杂的CSS动画可以借助此库实现，节省效率和时间成本。 animate.css官网 注意点: 1231. 需要使用自定义的class名形式去使用此CSS动画库2. class中需包含 animated 具体类名 + 具体动画名 页面代码如下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Vue中使用Animate.css库&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./vue-dev.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./vue-animate.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;transition name=&quot;fade&quot; appear enter-active-class=&quot;animated swing&quot; leave-active-class=&quot;animated bounce&quot; appear-active-class=&quot;animated swing&quot; &gt; &lt;div v-show=&quot;show&quot;&gt;hello world&lt;/div&gt; &lt;/transition&gt; &lt;button @click=&quot;handleClickEvent&quot;&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &apos;#app&apos;, data() &#123; return &#123; show: true &#125; &#125;, methods: &#123; handleClickEvent: function() &#123; this.show = !this.show; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 和其他动画的冲突影响: 和transition的动画时间不一致,可以指定其类型type 12345678910111213141516171819&lt;style type=&quot;text/css&quot;&gt; .fade-enter, .fade-leave-to &#123; opacity: 0; /*点击按钮页面即将被显示，此时div标签处于隐藏状态*/ &#125; .fade-enter-active,.fade-leave-active &#123; transition: opacity 3s; /* 对该CSS样式进行transition的监控,有3s的过渡*/ &#125; &lt;/style&gt; &lt;transition name=&quot;fade&quot; type=&quot;transition&quot; //设定那种动画时长为其结束时长 appear enter-active-class=&quot;animated swing&quot; leave-active-class=&quot;animated bounce&quot; appear-active-class=&quot;animated swing&quot; &gt; &lt;div v-show=&quot;show&quot;&gt;hello world&lt;/div&gt; &lt;/transition&gt; 自定义动画的总时长duration 123456789&lt;transition name=&quot;fade&quot; :duration=&quot;10000&quot; //自定义动画的总时长 appear enter-active-class=&quot;animated swing&quot; leave-active-class=&quot;animated bounce&quot; appear-active-class=&quot;animated swing&quot; //页面的初次动画 &gt; &lt;div v-show=&quot;show&quot;&gt;hello world&lt;/div&gt;&lt;/transition&gt; 同时可以定义显示时长和隐藏时长 123456789&lt;transition name=&quot;fade&quot; :duration=&quot;&#123;enter:5000,leave:10000&#125;&quot; //自定义显示/隐藏动画的时长 appear enter-active-class=&quot;animated swing&quot; leave-active-class=&quot;animated bounce&quot; appear-active-class=&quot;animated swing&quot; &gt; &lt;div v-show=&quot;show&quot;&gt;hello world&lt;/div&gt;&lt;/transition&gt;]]></content>
      <categories>
        <category>Vue动效篇</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PDF文档]]></title>
    <url>%2F2019%2F02%2F16%2FPDF%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[基于图文课程PDF文档阅读的展示(包含3种方式) WKWebView加载 (iOS8.0之后) QuickLook框架 - QLPreviewController加载 CoreGraphics框架绘制 一、WKWebView加载12iOS8.0之后,苹果已推出框架WebKit, WKWebView作为其中的浏览器控件,其加载速度,内存占用率都优于UIWebView,故此本文, 着重介绍WKWebView(UIWebView用法接近) 其用法简单如下: 二、QLPreviewController加载12QLPreviewController是系统自带的文件预览控制器,要使用QLPreviewController先得在文件中导入头文件#import &lt;QuickLook/QuickLook.h&gt;，并且实现其代理方法QLPreviewControllerDataSource QLPreviewController只能加载本地文件，不支持在线预览。显示效果比webView要好。 QLPreviewController会自带导航和工具栏, 如果要加载到视图中去, 需要将QLPreviewController中视图添加到父视图,且在iOS10.0之后,需要加入到子控制器中 三、CoreGraphics框架绘制CGContexDrawPDFPage和UIPageViewController实现翻页浏览功能 绘制内容: UIPageViewController, 在UIPageViewControllerTransitionStyleScroll模式下, 如果使用展现时创建的方式,展示视图,会出现页面在第二页或者倒数第二页重复的原因, 故本项目, 使用全局数据源存储, 可同时兼容两种方式的使用. 四、完整项目1项目中,详细展现了几种方式的使用, 并且封装了下载XKFileDownloader框架, 结合使用 Github地址: XKArticleTextContentBrowser]]></content>
      <categories>
        <category>Object-C</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods公有库详解]]></title>
    <url>%2F2019%2F01%2F29%2FCocoapods%E5%85%AC%E6%9C%89%E5%BA%93%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[创建远程仓库 (Github)1. 注册Github账号 – Github官网2. 创建工具类库2.1 基本信息填写12CocoaPods是托管在github上的，所有的Pods也都是托管在github上，因此我们首先需要创建一个属于自己的 github 仓库，如下图所示： 123456789101112131415信息注释:1. Repository name: 开源库的名字 (必填)2. Description : 开源库的功能作用描述3. Public: 开源仓库4. Private: 私有仓库,收费(如果是公司内部使用的话这里推荐大家使用私有的仓库) 5. Initialize this repository with a README: readme文件,建议勾选进行创建,这是对该库完整的一个说明文档6. gitgnore: 看情况自行选择类型7. License类型: MIT License (建议使用) 2.2 添加项目tag 1Repository主页 -&gt; release -&gt; create tag 2.3 clone 项目到本地 (客户端:GitHub Desktop)3. 基于cocoapods 自动创建3.1 执行命令:123打开终端 cd /Users/allenlas/Desktop/XKCocoapods 桌面路径下,执行:pod lib create XKCocoapods(项目名称) 回复问题: 项目文件层次结构: 1复制 XKCocoapods文件夹下的 XKCocoapods文件, 替换掉本地clone下来的XKCocoapods文件,最终如下: 3.2 配置podspec文件 1podsepc 配置完成, 需要提交到GitHub上,不然验证上会验证上一次提交的信息 3.3 完善Example1XKCocoapods文件-&gt; classes目录 -&gt; 添加XKCocoapods类 进入Example文件夹，执行pod install，让demo项目安装依赖项并更新配置 如下: 更新配置后, 提交代码到GitHub 3.4 验证podspec文件12345执行命令 : pod lib lint --allow-warnings pod spec lint --allow-warnings 验证成功: 常见错误,如: 1- ERROR | [iOS] file patterns: The `source_files` pattern did not match any file 此错误的原因是没有找到匹配的文件。 解决方案： 手动创建文件，具体操作方法如下: 1234567终端输入:open /Users/allenlas/Library/Caches/CocoaPods/Pods/External/XKCocoaPods进入最近的一个日志文件,创建文件夹与source_files文件路径对应:XKCocoapods文件-&gt; classes目录 -&gt; 添加XKCocoapods类 提交代码后, 重新验证 spec文件的可行性 4. 使用trunk push spec文件到cocoapods12345671. 如果是第一次使用,需要注册: pod trunk register yourmail@gmail.com &apos;yourName&apos; 3. 检查是否注册成功: pod trunk me4. push spec文件: pod trunk push XKCocoapods.podspec 上传成功: 5. 检查项目spec 是否上传成功1pod search xxxx(上传的项目名称) 常见错误: 1[!] Unable to find a pod with name, author, summary, or description matching `XKCocoapods` 执行命令 : 1234567pod setup或者删除本地搜索索引rm ~/Library/Caches/CocoaPods/search_index.json重新pod search XKCocoapods]]></content>
      <categories>
        <category>cocoapods</category>
      </categories>
      <tags>
        <tag>cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods安装]]></title>
    <url>%2F2019%2F01%2F29%2FCocoapods%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[CocoaPods简介12345CocoaPods是OS X和iOS下的一个第三类库管理工具,通过CocoaPods工具我们可以为项目添加被称为` Pods `的依赖库(这些类库必须是CocoaPods本身所支持的),并且可以轻松管理其版本1. 在引入第三方类库时,CocoaPods可以自动为Xcode项目配置好各种各样的配置,包括 配置变异阶段,连接器阶段,甚至是ARC环境的-fno-objc-arc 配置等.2.使用Cocoapods可以查找最新的第三库、并且是最新的、标准的第三方库,并且可以引用时更新最新版本第三方库 Ruby镜像准备 查看当前Ruby版本 1rvm -v ruby镜像源 12由于国内防火墙的问题,需要将镜像源更换为ruby-china,之前网上大多使用https://ruby.taobao.org,但taobao Gems 源已停止维护,现由 ruby-china 提供镜像服务. 因此,我们使用 https://gems.ruby-china.org/作为最新的镜像源服务 查看当前最新的镜像源,执行命令 1gem sources -l 如已是 ruby-china ,则跳过此步骤; 更换镜像源地址: 123gem sources --remove https://rubygems.org/gem sources --add https://gems.ruby-china.org/ 再次查看源路径是否更新成功 1gem sources -l 更新Ruby,执行命令(只有确保sources是ruby-china 才可以更新) 1sudo gem update --system 开始安装Cocoapods 查看是否已已安装,如已安装,则升级,步骤一致 1which pod 安装cocoapods ,执行命令 1sudo gem install cocoapods 中间可能出现该错误12ERROR: While executing gem ... (Errno::EPERM) Operation not permitted -/usr/bin/pod 如有以上错误,执行命令1sudo gem install -n /usr/local/bin cocoapods 安装过程可能需要点时间 ,尽量在确保网速可以的环境下安装,耐心等待,成功后,可以执行命令查看 1pod --version 安装成功后,设置本地仓库 123即把所有上传到cocoapods的第三方框架下载每个版本和网络地址以及一些其他描述信息到本地,因为服务器是在国外,所以比较耗时间,执行命令:pod setup 查看pod 命令帮助 1pod help 如何使用Cocoapods?场景1: 使用Xcode新建工程项目,引入AFNetworking类库 查看AFNetworking是否支持Cocoapods 1pod search AFNetworking 如果中间出现错误:1[!] Unable to find a pod with name, author, summary, or descriptionmatching &apos;······&apos; 如有以上错误,则可以删除本地 search_index.json 文件,重新pod search,命令如下: 123· rm ~/Library/Caches/CocoaPods/search_index.json· pod search AFNetworking 搜索成功后: Xcode新建项目,创建 Podfile 文件 123cd 项目路径到terminal终端 ,执行命令pod init 打开Podfile文件, 输入以下文字(一般不提倡指定版本,不利于更新类库),保存: 1pod &quot;AFNetworking&quot; 或指定版本 pod &apos;AFNetworking&apos;, &apos;~&gt; 3.2.1&apos; 使用Cocoapods引入AFNetworking类库 1pod install --no-repo-install 或 pod update --no-repo-update 在项目中引入 AFNetworking类库 1#import &lt;AFNetworking.h&gt; 或 #import &quot;AFNetworking.h&quot; 如果在项目中 #import 第三方类库.h文件没有提示,则需要把pods目录添加到用户头文件检索的路径到Xcode中 123Xcode 选择target -&gt; BuildSettings -&gt; search Paths -&gt; User Header Search Paths点击“+”号添加一项：并且输入：$(PODS_ROOT) , 选择：recursive（会在相应的目录递归搜索文件）]]></content>
      <categories>
        <category>Cocoapods</category>
      </categories>
      <tags>
        <tag>Cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue环境搭建]]></title>
    <url>%2F2019%2F01%2F02%2FVue%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Vue 环境搭建 &ensp; &ensp; 在使用vue.js 构建大型应用的时候推荐使用 NPM 安装方法, NPM能很好的和诸如 &nbsp;Webpack &nbsp;或者 &nbsp;Browserify 模块打包器配合使用 工具: node.js环境(npm包安装) vue-cli脚手架构建工具 cnpm npm淘宝镜像 1. Homebrew安装123456Homebrew简称brew，是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件打开终端,执行以下命令安装Homebrew:ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 2. Node安装123打开终端,执行以下命令安装node: brew install node查看版本,检查是否安装成功: node -v npm -v 3. Cnpm安装1234567cnpm和npm用法一致, 只是使用过的是国内的淘宝镜像,效率会比npm高很多打开终端,执行以下命令安装cnpm:npm install cnpm -g --registry=https://registry.npm.taobao.org查看版本,检查是否安装成功: cnpm -v 4. vue-cli (脚手架构建工具)123打开终端,执行以下命令安装vue-cli:npm install -g vue-cli 或 cnpm install -g vue-cli 5. vue-init 构建项目123451.新建目录 web-vue 文件夹2.打开终端,执行以下命令构建项目: vue init webpack first-app 12345678910111213Project name :项目名称 如果不需要更改直接回车就可以了。注意：这里不能使用大写Project description:项目描述，默认为A Vue.js project,直接回车，不用编写。Author：作者，如果你有配置git的作者，它会读取Install vue-router? 是否安装vue的路由插件，我们这里需要安装，所以选择YUse ESLint to lint your code? 是否用ESLint来限制你的代码错误和风格。我们这里不需要输入n（建议），如果你是大型团队开发，最好是进行配置。setup unit tests with Karma + Mocha? 是否需要安装单元测试工具Karma+Mocha，我们这里不需要，所以输入nSetup e2e tests with Nightwatch?是否安装e2e来进行用户行为模拟测试，我们这里不需要，所以输入n 5. cnpm 安装依赖12345打开终端 cd 到first-app的路径中: 执行命令 cnpm install 安装完成之后，在first-app项目中，会多一个node_modules文件夹，这里面就是我们所需要的依赖包资源 6. 启动服务12345打开终端 cd 到first-app的路径中: 执行命令 npm run dev 或 cnpm run dev 或 npm start安装完成之后，在first-app项目中，会多一个node_modules文件夹，这里面就是我们所需要的依赖包资源 7. 打包上线1234567注意: 项目中的文件都需要放到src 目录下 打开终端 cd 到src的路径中: 执行命令 npm run build 进行项目打包 打包完成后, 项目会生成一个dist文件夹, 项目上线时, 只需要将dist文件夹放到服务器就可以了]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AVFoundation学习笔记]]></title>
    <url>%2F2019%2F01%2F02%2FAVFoundation%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[AVFoundation学习笔记12345本博文内容:1. 实现二维码扫描2. 实现自定义相机拍照功能3. 实现图片捕捉功能4. 附加: 手电筒的打开 关闭 捕捉设备AVCaptureDevice为诸如摄像头或麦克风等物理设备定义了一个接口。针对物理设备定义了大量控制方法，包括对焦、白平衡、曝光等。最常用的方法是1+ (nullable AVCaptureDevice *)defaultDeviceWithMediaType:(AVMediaType)mediaType 捕捉会话 AVCaptureSession(媒体捕捉的核心类),用于连接输入输出的资源。捕捉会话有一个会话预设值，用于控制捕捉数据的格式和质量，默认为AVCaptureSessionPresentHigh 基础使用: 1备注: AVCaptureSession的开启和停止,在完全开启或完全结束之前都会阻塞线程, 因此这里必须放在后台线程中处理，否则，就会导致界面不响. 捕捉设备的输入在使用捕捉设备进行处理前，首先要添加一个输入设备，不过一个捕捉设备不能直接添加到AVCaptureSession，但可以将它封装到AVCaptureDeviceInput实例中来添加，使用-deviceInputWithDevice:error:方法 捕捉的输出AVCaptureOutput是一个抽象基类，用于为从捕捉会话得到的数据输入到目的地。应使用这个类的一些派生类如： 12341. AVCaptureStillImageOuptut 静态图片输出(拍照)2. AVCaptureMovieFileOutput 视频输出(视频录制)3. AVCaptureVideoDataOutput 视频数据输出(连拍,视频录制)4. AVCaptureAudioDataOutput:音频数据输出 捕捉预览AVCaptureVideoPreviewLayer可满足在捕捉时的实时预览，类似于AVPlayerLayer的角色，支持重力概念，可控制视频内容渲染和缩放、拉伸效果. 手电筒的打开、关闭基本方法: 实现二维码扫描AVCaptureMetadataOutput 用于处理AVCaptureSession产生的定时元数据的捕获输出，继承自 AVCaptureOutput AVMetadataObjectType,元数据类型,主要如下: 遵从协议AVCaptureMetadataOutputObjectsDelegate 1- (void)captureOutput:(AVCaptureOutput *)output didOutputMetadataObjects:(NSArray&lt;__kindof AVMetadataObject *&gt; *)metadataObjects fromConnection:(AVCaptureConnection *)connection 基础代码如下: 自定义拍照基础方法: 实现连拍AVCaptureVideoDataOutput,原始视频帧，用于获取实时图像以及视频录制遵从协议:AVCaptureVideoDataOutputSampleBufferDelegate 12//AVCaptureVideoDataOutput获取实时图像，这个代理方法的回调频率很快，几乎与手机屏幕的刷新频率一样快- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection; 基础方法: 完整项目输出Github地址: XKCaptureMetadataKit]]></content>
      <categories>
        <category>Object-C</category>
      </categories>
      <tags>
        <tag>AVFoundation(媒体捕捉、二维码)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AppStore证书 (开发打包、推送、上架)]]></title>
    <url>%2F2018%2F12%2F29%2FiOS-%E8%AF%81%E4%B9%A6%E7%AF%87%2F</url>
    <content type="text"><![CDATA[一. 前期准备12个人开发者或者企业开发者账号申请已有账号,则直接登录, 开发者中心 https://developer.apple.com/ 开发者中心页面: 二、证书申请 2.1 创建App ID 选择Identifiers下的All IDs，右侧显示了所有已创建的App ID,点击右上角“+”新建: 信息填写(生成id)1234567891011App ID Description: 填写容易辨识的名称(可用项目名称,不可用中文)App ID Suffix:(2种) 1.Explicit App ID(首选) : 精确型, Bundle ID需要填写和你的项目名称一模一样, 例如com.xk.movie 2.Wildcard App ID：通配型,bundle ID只需要填写前缀即可：com.artron.＊,这样只要是项目的Bundle Identifier的前缀和这个一样都可以使用 通常项目开发,都是使用第一种精确型,确保唯一匹配 App Services: 应用需要用到的服务,如果有使用推送功能,则需要勾选Push Notification. 可后期编辑时,再补充 2.2 创建Certificate证书2.2.1 创建证书请求文件1步骤: 电脑应用程序 -&gt; 使用工具 -&gt; 钥匙串访问 -&gt; 证书助理 -&gt; 从证书颁发机构请求证书 钥匙串工具 证书信息填写 12345电子邮箱地址: 可以随意填写邮箱地址(有效)常用名称: 容易辨识的名称(会显示到钥匙串), 可填写项目名称选择存储到磁盘,点击继续保存到桌面, 则会生成一个CertificateSigningRequest.certSigningRequest的证书请求文件 2.2.2 制作Certificate证书证书中心123Development: 开发证书 Production : 推送证书 APN : 推送证书每一个证书都需要单独创建,可使用同一个CertificateSigningRequest.certSigningRequest的证书请求文件 证书制作: 上传certSigningRequest的证书请求文件 12 如果是发布到AppStore,就选Production下的App Store and Ad Hoc;上传好请求文件后,会生成生成一个ios_development.cer证书文件, 点击download, 双击安装 到钥匙串中（如果安装不上，可以直接将证书文件拖拽到钥匙串访问的列表中） 2.3 制作 Provisioning Profile描述文件(PP证书)选择Provisioning Profiles下的All，右侧显示了所有已创建的profile,点击右上角“+”新建: 选择对应的APP ID 选择对应的证书 选择可安装的手机设备 填写profile名称 12为你的描述证书起个名字,一般是项目名称,继续即可完成创建,然后下载到电脑,双击即可安装到Xcode中;到此,证书的申请基本完成 三、项目配置(Xcode)3.1 添加开发者账号 3.2 Xcode证书配置1Xcode target -&gt; General -&gt; Singning (勾选 Automatically manage signing) -&gt; 编译项目 四、项目打包(Xcode)1Xcode真机模式 -&gt; Product -&gt; Archive 打包 4.1 上传到App Store直接在打包工具上传 4.2 导出ipa文件,使用Application Loader上传到App Store123打包工具 archive export -&gt; ipa文件(全部next,默认选中) -&gt; 生成ipa文件Xcode (open Developer Tool) -&gt; Application Loader -&gt; 选中本地ipa文件上传 1注意: 两种方式都需要耐心等待, 都是在验证ipa二进制数据, 所以会有点忙, 尽量在网络环境好的条件下上传 五、App Store Connect 提交审核1ipa 文件上传成功后, 可在此区域查看到上传到项目版本, 以及处理状态 六、App Store Connect 基本信息填写6.1 新建app 1注意:套装id 和 SKU 都可以填写项目的bundleid, 和开发者中心的证书bundleid一致,且在应用创建后,这两个不可再更改 6.2 App Information 12345Privacy Policy URL(隐私政策) : 可选项,可以不填写Category(类别):选择你的应用的分类Pricing and Availability: 选择价格信息即可 1234567891011app预览和应用截图, 可以使用6.5英寸(1242 x 2688)和5.5英寸(1242 x 2208)的sizeApp Icon : 像素为1024 x 1024的无圆角,无透明像素的图标手机号码: 需要加+86 ,例如 +8613666666666Demo Account:测试账号,如果你的应用需要登录,请提供一个开启了所有权限的测试账号Notes: 其他你认为有必要告诉苹果的审核人员的信息可以写在这里;注: 联系方式,姓名等信息尽可能真实, 要确保能够正常联系到, 已防止审核过程中出现问题, 苹果官方审核团队会致电通知]]></content>
      <categories>
        <category>Object-C</category>
      </categories>
      <tags>
        <tag>AppStore证书</tag>
      </tags>
  </entry>
</search>
